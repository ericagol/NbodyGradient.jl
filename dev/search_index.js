var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/#Initial-Conditions","page":"API","title":"Initial Conditions","text":"","category":"section"},{"location":"api/#NbodyGradient.CartesianIC","page":"API","title":"NbodyGradient.CartesianIC","text":"CartesianIC{T<:AbstractFloat} <: InitialConditions{T}\n\nInitial conditions, specified by the Cartesian coordinates and masses of each body.\n\nFields\n\nx::Matrix{T} : Positions of each body [dimension, body].\nv::Matrix{T} : Velocities of each body [dimension, body].\nm::Vector{T} : masses of each body.\nnbody::Int64 : Number of bodies in system.\nt0::T : Initial time.\n\n\n\n\n\n","category":"type"},{"location":"api/#NbodyGradient.Elements","page":"API","title":"NbodyGradient.Elements","text":"Elements{T<:AbstractFloat} <: AbstractInitialConditions\n\nOrbital elements of a binary, and mass of a 'outer' body. See Tutorials for units and conventions.\n\nFields\n\nm::T : Mass of outer body.\nP::T : Period [Days].\nt0::T : Initial time of transit [Days].\necosω::T : Eccentricity vector x-component (eccentricity times cosine of the argument of periastron)\nesinω::T : Eccentricity vector y-component (eccentricity times sine of the argument of periastron)\nI::T : Inclination, as measured from sky-plane [Radians].\nΩ::T : Longitude of ascending node, as measured from +x-axis [Radians].\na::T : Orbital semi-major axis [AU].\ne::T : Eccentricity.\nω::T : Argument of periastron [Radians].\ntp::T : Time of periastron passage [Days].\n\n\n\n\n\n","category":"type"},{"location":"api/#NbodyGradient.Elements-Union{Tuple{T}, NTuple{7, T}} where T<:Real","page":"API","title":"NbodyGradient.Elements","text":"Elements(m,P,t0,ecosω,esinω,I,Ω)\n\nMain Elements constructor. May use keyword arguments, see Tutorials.\n\n\n\n\n\n","category":"method"},{"location":"api/#NbodyGradient.ElementsIC","page":"API","title":"NbodyGradient.ElementsIC","text":"ElementsIC{T<:AbstractFloat} <: InitialConditions{T}\n\nInitial conditions, specified by a hierarchy vector and orbital elements.\n\nFields\n\nelements::Matrix{T} : Masses and orbital elements.\nϵ::Matrix{T} : Matrix of Jacobi coordinates\namat::Matrix{T} : 'A' matrix from Hamers and Portegies Zwart 2016.\nnbody::Int64 : Number of bodies.\nm::Vector{T} : Masses of bodies.\nt0::T : Initial time [Days].\n\n\n\n\n\n","category":"type"},{"location":"api/#NbodyGradient.ElementsIC-Union{Tuple{T}, Tuple{T, Matrix{<:Real}, Vararg{Elements{T}}}} where T<:AbstractFloat","page":"API","title":"NbodyGradient.ElementsIC","text":"ElementsIC(t0,H,elems)\n\nCollects Elements and produces an ElementsIC struct.\n\nArguments\n\nt0::T : Initial time [Days].\nH : Hierarchy specification.\nelems : The orbital elements and masses of the system.\n\n\n\nThere are a number of way to specify the initial conditions. Below we've described the arguments ElementsIC takes. Any combination of H and elems may be used. For a concrete example see Tutorials.\n\nElements\n\nelems... : A sequence of Elements{T}. Elements should be passed in the order they appear in the hierarchy (left to right).\nelems::Vector{Elements} : A vector of Elements. As above, Elements should be in order.\nelems::Matrix{T} : An matrix containing the masses and orbital elements.\nelems::String : Name of a file containing the masses and orbital elements.\n\nEach method is simply populating the ElementsIC.elements field, which is a Matrix{T}.\n\nHierarchy\n\nNumber of bodies: H::Int64: The system will be given by a 'fully-nested' Keplerian.\n\nH = 4 corresponds to:\n\n3        ____|____\n        |         |\n2    ___|___      d\n    |       |\n1 __|__     c\n |     |\n a     b\n\nHierarchy Vector: H::Vector{Int64}: The first elements is the number of bodies. Each subsequent is the number of binaries on a level of the hierarchy.\n\nH = [4,2,1]. Two binaries on level 1, one on level 2.\n\n2    ____|____\n    |         |\n1 __|__     __|__\n |     |   |     |\n a     b   c     d\n\nFull Hierarchy Matrix: H::Matrix{<:Real}: Provide the hierarchy matrix, directly.\n\nH = [-1 1 0 0; 0 0 -1 1; -1 -1 1 1; -1 -1 -1 -1]. Produces the same system as H = [4,2,1].\n\n\n\n\n\n","category":"method"},{"location":"api/#State","page":"API","title":"State","text":"","category":"section"},{"location":"api/#NbodyGradient.State","page":"API","title":"NbodyGradient.State","text":"State{T<:AbstractFloat} <: AbstractState\n\nCurrent state of simulation.\n\nFields (relevant to the user)\n\nx::Matrix{T} : Positions of each body [dimension, body].\nv::Matrix{T} : Velocities of each body [dimension, body].\nt::Vector{T} : Current time of simulation.\nm::Vector{T} : Masses of each body.\njac_step::Matrix{T} : Current Jacobian.\ndqdt::Vector{T} : Derivative with respect to time.\n\n\n\n\n\n","category":"type"},{"location":"api/#NbodyGradient.State-Union{Tuple{InitialConditions{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"NbodyGradient.State","text":"State(ic)\n\nConstructor for State type.\n\nArguments\n\nic::InitialConditions{T} : Initial conditions for the system.\n\n\n\n\n\n","category":"method"},{"location":"api/#Integrator","page":"API","title":"Integrator","text":"","category":"section"},{"location":"api/#NbodyGradient.Integrator","page":"API","title":"NbodyGradient.Integrator","text":"Integrator{T<:AbstractFloat}\n\nIntegrator. Used as a functor to integrate a State.\n\nFields\n\nscheme::Function : The integration scheme to use.\nh::T : Step size.\nt0::T : Initial time.\ntmax::T : Duration of simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#TransitTiming","page":"API","title":"TransitTiming","text":"","category":"section"},{"location":"api/#NbodyGradient.TransitParameters","page":"API","title":"NbodyGradient.TransitParameters","text":"TransitParameters{T<:AbstractFloat} <: TransitOutput{T}\n\nTransit times, impact parameters, sky-velocities, and derivatives.\n\n(User-facing) Fields\n\nttbv::Matrix{T} : The transit times, impact parameter, and sky-velocity of each body.\ndtbvdq0::Array{T,5} : Derivatives of the transit times, impact parameters, and sky-velocities with respect to the initial Cartesian coordinates and masses.\ndtbvdelements::Array{T,5} : Derivatives of the transit times, impact parameters, and sky-velocities with respect to the initial orbital elements and masses.\n\n\n\n\n\n","category":"type"},{"location":"api/#NbodyGradient.TransitParameters-Union{Tuple{T}, Tuple{T, ElementsIC{T}}, Tuple{T, ElementsIC{T}, Int64}} where T<:AbstractFloat","page":"API","title":"NbodyGradient.TransitParameters","text":"TransitParameters(tmax, ic; ti)\n\nConstructor for TransitParameters type.\n\nArguments\n\ntmax::T : Expected total elapsed integration time. (Allocates arrays accordingly)\nic::ElementsIC{T} : Initial conditions for the system\n\nOptional\n\nti::Int64=1 : Index of the body with respect to which transits are measured. (Default is the central body)\n\n\n\n\n\n","category":"method"},{"location":"api/#NbodyGradient.TransitTiming","page":"API","title":"NbodyGradient.TransitTiming","text":"TransitTiming{T<:AbstractFloat} <: TransitOutput{T}\n\nTransit times and derivatives.\n\n(User-facing) Fields\n\ntt::Matrix{T} : The transit times of each body.\ndtdq0::Array{T,4} : Derivatives of the transit times with respect to the initial Cartesian coordinates and masses.\ndtdelements::Array{T,4} : Derivatives of the transit times with respect to the initial orbital elements and masses.\n\n\n\n\n\n","category":"type"},{"location":"api/#NbodyGradient.TransitTiming-Union{Tuple{T}, Tuple{T, ElementsIC{T}}, Tuple{T, ElementsIC{T}, Int64}} where T<:AbstractFloat","page":"API","title":"NbodyGradient.TransitTiming","text":"TransitTiming(tmax, ic; ti)\n\nConstructor for TransitTiming type.\n\nArguments\n\ntmax::T : Expected total elapsed integration time. (Allocates arrays accordingly)\nic::ElementsIC{T} : Initial conditions for the system\n\nOptional\n\nti::Int64=1 : Index of the body with respect to which transits are measured. (Default is the central body)\n\n\n\n\n\n","category":"method"},{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"basic.md\", \"gradients.md\"]","category":"page"},{"location":"basic/#Basic-Usage","page":"Basic Usage","title":"Basic Usage","text":"","category":"section"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"Here we'll walk through an example of integrating a 3-body system.","category":"page"},{"location":"basic/#Units","page":"Basic Usage","title":"Units","text":"","category":"section"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"A quick note on the units used throughout the code.","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"Distance: AU\nTime: Days\nMass: Solar Masses\nAngles: Radians","category":"page"},{"location":"basic/#Initial-Conditions","page":"Basic Usage","title":"Initial Conditions","text":"","category":"section"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"First, we define the orbital elements of the system. This can be done by creating Elements for each body in the system.","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"Start with a 1 solar mass star","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"using NbodyGradient\n\na = Elements(m = 1.0);\nnothing # hide","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"We then define the orbital elements for second body, say an Earth analogue.","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"b = Elements(\n    m = 3e-6,     # Mass [Solar masses]\n    t0 = 0.0,     # Initial time of transit [days]\n    P = 365.256,  # Period [days]\n    ecosω = 0.01, # Eccentricity * cos(Argument of Periastron)\n    esinω = 0.0,  # Eccentricity * sin(Argument of Periastron)\n    I = π/2,      # Inclination [Radians]\n    Ω = 0.0       # Longitude of Ascending Node [Radians]\n);\nnothing # hide","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"(ecosω can be typed as ecos\\omega and then hitting tab)","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"Next we'll create a Jupiter analogue for the final body. Here the orbital elements are specified for the Keplerian ((a,b),c), or c orbiting the center of mass of a and b. (While this might not need to be stated explicitly here, this convention is useful for more complicated hierarchical systems).","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"c = Elements(\n    m = 9.54e-4,\n    P = 4332.59,\n    ecosω = 0.05,\n    I = π/2\n);\nnothing # hide","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"Here, we can simply omit any orbital elements which are zero. Unspecified elements are set to zero by default.","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"Now we need to pass our Elements to ElementsIC.","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"t0 = 0.0 # Initial time\nN = 3    # Number of bodies\nic = ElementsIC(t0,N,a,b,c)","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"Finally, we can pass the initial conditions to State, which converts orbital elements to cartesian coordinates (and calculates the derivatives with respect to the initial conditions).","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"s = State(ic);\nnothing # hide","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"The positions and velocities can be accessed by s.x and s.v, respectively. Each matrix contains the vector component (rows) for a particular body (columns).","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"s.x","category":"page"},{"location":"basic/#Integration","page":"Basic Usage","title":"Integration","text":"","category":"section"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"Now that we have initial conditions, we can construct and run the integrator. First, define an Integrator, specifying the integration scheme, the time step, and final time. We'll use the ahl21! mapping.","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"h = b.P/30.0 # We want at most 1/20th of the smallest period for a time step\ntmax = 5*c.P # Integrate for 5 orbital periods of the outer body\nintr = Integrator(ahl21!,h,tmax);\nnothing # hide","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"note: A quick aside on constructors\nThe types in NbodyGradient.jl have a number of constructors that enable to user to write as terse or as verbose code as they would like. For example, the above Integrator construction could specify each field as Integrator(scheme, h, t0, tmax) (see Integrator for argument definitions), or only the time step and integration time as Integrator(h,tmax). In the latter case, the default value for scheme and t0 are ahl21! and 0, respectively. If you're coming from Agol, Hernandez, and Langford (2021) you'll notice some discrepancy in the examples due to this.","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"Finally, run the Integrator by passing it the State.","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"intr(s)\ns.x # Show final positions","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"This integrates from s.t to s.t+tmax, steping by h. If you'd rather step a certain number of time steps:","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"N = 1000\nintr(s,N)","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"note: Re-running simulations\nIf you want to run the integration from the initial condtions again, you must 'reset' the State. I.e. run s = State(ic). Otherwise, the integration will begin from what ever s.t is currently equal to, and with those coordinates.","category":"page"},{"location":"basic/#Transit-Timing","page":"Basic Usage","title":"Transit Timing","text":"","category":"section"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"If we wish to compute transit times, we need only to pass a TransitTimingstructure to the Integrator.","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"s = State(ic) # Reset to the initial conditions\ntt = TransitTiming(tmax, ic)\nintr(s,tt)","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"To see the first 5 transit times of our second body about the first body, run:","category":"page"},{"location":"basic/","page":"Basic Usage","title":"Basic Usage","text":"tt.tt[2,1:5]","category":"page"},{"location":"#NbodyGradient","page":"Index","title":"NbodyGradient","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"A fast, differentiable N-body integrator for modeling transiting exoplanets, and more.","category":"page"},{"location":"","page":"Index","title":"Index","text":"This package provides a simple user-interface to carry out N-body simulations and compute the derivatives of the outputs with respect to the initial conditions. The current version of the code implements the following:","category":"page"},{"location":"","page":"Index","title":"Index","text":"Integrators:\nAHL21 (4th-order Symplectic; Agol, Hernandez, & Langford 2021)\nInitial Conditions:\nCartesian coordinates (CartesianIC)\nOrbital elements (ElementsIC)\nOutput Models:\nTransit times (TransitTiming)\nTransit times, impact parameter, and sky-plane velocity (TransitParameters)","category":"page"},{"location":"#Getting-Started","page":"Index","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"First, you'll need to add the package. Using the Julia REPL, run:","category":"page"},{"location":"","page":"Index","title":"Index","text":"pkg> add NbodyGradient","category":"page"},{"location":"","page":"Index","title":"Index","text":"If you'd like to use the developement version of the code, run:","category":"page"},{"location":"","page":"Index","title":"Index","text":"pkg> add NbodyGradient#master","category":"page"},{"location":"","page":"Index","title":"Index","text":"Then, use like any other Julia package","category":"page"},{"location":"","page":"Index","title":"Index","text":"using NbodyGradient","category":"page"},{"location":"","page":"Index","title":"Index","text":"See the Tutorials page for basic usage.","category":"page"},{"location":"gradients/#Gradients","page":"Gradients","title":"Gradients","text":"","category":"section"},{"location":"gradients/","page":"Gradients","title":"Gradients","text":"The main purpose of developing NbodyGradient.jl is to provide a differentiable N-body model for gradient-based optimization. Here, we walk though computing and accessing the jacobian of the transit times with respect to the initial orbital elements and masses.","category":"page"},{"location":"gradients/","page":"Gradients","title":"Gradients","text":"We assume you've taken a look at the Basic Usage tutorial, and are familiar with the orbital elements and units used in NbodyGradient.jl.","category":"page"},{"location":"gradients/","page":"Gradients","title":"Gradients","text":"note: No gradient support for exactly circular orbits\nThis package supports specifying initial conditions for circular orbits (ie. eccentricity=0). However, the derivative computations contain 1/e terms – requiring a non-zero eccentricity to be computed correctly. We expect the need for derivatives for exactly circular initial orbits to be minimal, and intend to implement them in the future.","category":"page"},{"location":"gradients/","page":"Gradients","title":"Gradients","text":"Here, we will specify the orbital elements using the 'elements matrix' option (See ElementsIC).","category":"page"},{"location":"gradients/","page":"Gradients","title":"Gradients","text":"using NbodyGradient\n\n# Initial Conditions\nelements = [\n  # m    P       t0  ecosω esinω I   Ω\n    1.0  0.0     0.0 0.0   0.0   0.0 0.0; # Star\n    3e-6 365.256 0.0 0.01  0.0   π/2 0.0; # Earth analogue\n]\nic = ElementsIC(0.0, 2, elements);\nnothing # hide","category":"page"},{"location":"gradients/","page":"Gradients","title":"Gradients","text":"Let's integrate for 5 periods of the planet and record the transit times.","category":"page"},{"location":"gradients/","page":"Gradients","title":"Gradients","text":"s = State(ic)\n\nP = elements[2,2] # Get the period from the elements matrix\ntmax = 5 * P\ntt = TransitTiming(5 * P, ic)\n\nh = P/30.0\nIntegrator(h, tmax)(s, tt) # Run without creating an `Integrator` variable.\n\n# Computed transit times\ntt.tt","category":"page"},{"location":"gradients/","page":"Gradients","title":"Gradients","text":"The derivatives of the transit times with respect to the initial orbitial elements and masses are held in the dtdelements field of the TransitTiming structure – an Array{T<:AbstractFloat,4}. The indices correspond to the transiting body, transit number, orbital element, and body the orbital element is describing. For example, this is how to access the 'gradient' of the first transit time of the orbiting body:","category":"page"},{"location":"gradients/","page":"Gradients","title":"Gradients","text":"tt.dtdelements[2,1,:,:]","category":"page"},{"location":"gradients/","page":"Gradients","title":"Gradients","text":"Here, the first column is the derivative of the transit time with respect to the stars 'orbital elements', which are all zero except for the mass in the last row. The second column is the derivatives with respect to the orbital elements of the system.","category":"page"}]
}
